import {mean} from './math/tool.js';
//声明
let IIRCoeff_H05_o3 = [
	0.993736502354, -2.98120950706, 2.98120950706, -0.993736502354, -2.98743365006, 2.97494613267, -0.987512236111,
];
let IIRCoeff_X50_o2 = [0.95210179687, -1.54248128889, 0.95210179687, -1.54248128889, 0.904203593739];
let IIRCoeff_X50_o4 = [
	0.93137885812298226718, -3.0178169314315956839, 4.307310475900904656, -3.0178169314315956839, 0.93137885812298226718,
	-3.1251698187775707183, 4.3025960583551974281, -2.9104640440856166528, 0.86747213379166798752,
];
let IIRCoeff_L35_o3 = [
	0.00716766742664, 0.0215030022799, 0.0215030022799, 0.00716766742664, -2.12663805723, 1.59581852959, -0.41183913295,
];
let IIRCoeff_H05_50_o3 = [
	[0.9509718879, -2.852915664, 2.852915664, -0.9509718879, -2.899479595, 2.803947977, -0.9043475314],
	[0.9518090346, -2.855427104, 2.855427104, -0.9518090346, -2.901238343, 2.807293496, -0.9059404381],
	[0.9526469091, -2.857940727, 2.857940727, -0.9526469091, -2.902997109, 2.81064203, -0.9075361332],
	[0.9534855122, -2.860456537, 2.860456537, -0.9534855122, -2.904755895, 2.813993581, -0.9091346218],
	[0.9543248447, -2.862974534, 2.862974534, -0.9543248447, -2.906514699, 2.81734815, -0.9107359091],
	[0.9551649075, -2.865494722, 2.865494722, -0.9551649075, -2.908273521, 2.820705739, -0.9123400003],
	[0.9560057012, -2.868017103, 2.868017103, -0.9560057012, -2.91003236, 2.824066349, -0.9139469005],
	[0.9568472266, -2.87054168, 2.87054168, -0.9568472266, -2.911791217, 2.827429981, -0.915556615],
	[0.9576894847, -2.873068454, 2.873068454, -0.9576894847, -2.91355009, 2.830796638, -0.917169149],
	[0.9585324761, -2.875597428, 2.875597428, -0.9585324761, -2.915308981, 2.83416632, -0.9187845076],
	[0.9593762017, -2.878128605, 2.878128605, -0.9593762017, -2.917067887, 2.83753903, -0.9204026962],
	[0.9602206622, -2.880661987, 2.880661987, -0.9602206622, -2.91882681, 2.840914767, -0.92202372],
	[0.9610658585, -2.883197575, 2.883197575, -0.9610658585, -2.920585748, 2.844293535, -0.9236475843],
	[0.9619117913, -2.885735374, 2.885735374, -0.9619117913, -2.922344702, 2.847675334, -0.9252742942],
	[0.9627584615, -2.888275384, 2.888275384, -0.9627584615, -2.92410367, 2.851060166, -0.9269038551],
	[0.9636058698, -2.890817609, 2.890817609, -0.9636058698, -2.925862653, 2.854448033, -0.9285362723],
	[0.9644540171, -2.893362051, 2.893362051, -0.9644540171, -2.927621651, 2.857838935, -0.9301715511],
	[0.9653029042, -2.895908713, 2.895908713, -0.9653029042, -2.929380662, 2.861232874, -0.9318096968],
	[0.9661525318, -2.898457595, 2.898457595, -0.9661525318, -2.931139687, 2.864629853, -0.9334507146],
	[0.9670029008, -2.901008702, 2.901008702, -0.9670029008, -2.932898725, 2.868029871, -0.9350946101],
	[0.9678540119, -2.903562036, 2.903562036, -0.9678540119, -2.934657776, 2.87143293, -0.9367413884],
	[0.968705866, -2.906117598, 2.906117598, -0.968705866, -2.93641684, 2.874839033, -0.9383910549],
	[0.969558464, -2.908675392, 2.908675392, -0.969558464, -2.938175916, 2.87824818, -0.940043615],
	[0.9704118065, -2.911235419, 2.911235419, -0.9704118065, -2.939935004, 2.881660374, -0.9416990742],
	[0.9712658944, -2.913797683, 2.913797683, -0.9712658944, -2.941694104, 2.885075614, -0.9433574377],
	[0.9721207286, -2.916362186, 2.916362186, -0.9721207286, -2.943453214, 2.888493903, -0.9450187109],
	[0.9729763098, -2.918928929, 2.918928929, -0.9729763098, -2.945212336, 2.891915243, -0.9466828994],
	[0.9738326388, -2.921497916, 2.921497916, -0.9738326388, -2.946971468, 2.895339634, -0.9483500084],
	[0.9746897165, -2.924069149, 2.924069149, -0.9746897165, -2.948730611, 2.898767078, -0.9500200434],
	[0.9755475437, -2.926642631, 2.926642631, -0.9755475437, -2.950489763, 2.902197576, -0.95169301],
	[0.9764061212, -2.929218363, 2.929218363, -0.9764061212, -2.952248925, 2.905631131, -0.9533689134],
	[0.9772654498, -2.931796349, 2.931796349, -0.9772654498, -2.954008097, 2.909067742, -0.9550477593],
	[0.9781255303, -2.934376591, 2.934376591, -0.9781255303, -2.955767277, 2.912507413, -0.956729553],
	[0.9789863636, -2.936959091, 2.936959091, -0.9789863636, -2.957526465, 2.915950143, -0.9584143001],
	[0.9798479504, -2.939543851, 2.939543851, -0.9798479504, -2.959285662, 2.919395936, -0.960102006],
	[0.9807102917, -2.942130875, 2.942130875, -0.9807102917, -2.961044867, 2.922844791, -0.9617926763],
	[0.9815733882, -2.944720165, 2.944720165, -0.9815733882, -2.962804079, 2.92629671, -0.9634863164],
	[0.9824372408, -2.947311722, 2.947311722, -0.9824372408, -2.964563298, 2.929751696, -0.965182932],
	[0.9833018502, -2.949905551, 2.949905551, -0.9833018502, -2.966322525, 2.933209748, -0.9668825286],
	[0.9841672173, -2.952501652, 2.952501652, -0.9841672173, -2.968081757, 2.93667087, -0.9685851117],
	[0.985033343, -2.955100029, 2.955100029, -0.985033343, -2.969840996, 2.940135061, -0.9702906868],
	[0.985900228, -2.957700684, 2.957700684, -0.985900228, -2.971600241, 2.943602324, -0.9719992596],
	[0.9867678733, -2.96030362, 2.96030362, -0.9867678733, -2.973359491, 2.947072659, -0.9737108357],
	[0.9876362795, -2.962908839, 2.962908839, -0.9876362795, -2.975118747, 2.950546069, -0.9754254206],
	[0.9885054477, -2.965516343, 2.965516343, -0.9885054477, -2.976878007, 2.954022554, -0.97714302],
	[0.9893753785, -2.968126135, 2.968126135, -0.9893753785, -2.978637272, 2.957502117, -0.9788636395],
	[0.9902460728, -2.970738219, 2.970738219, -0.9902460728, -2.98039654, 2.960984758, -0.9805872848],
	[0.9911175316, -2.973352595, 2.973352595, -0.9911175316, -2.982155813, 2.964470478, -0.9823139614],
	[0.9919897555, -2.975969266, 2.975969266, -0.9919897555, -2.983915089, 2.96795928, -0.984043675],
	[0.9928627455, -2.978588236, 2.978588236, -0.9928627455, -2.985674368, 2.971451164, -0.9857764314],
	[0.9937365024, -2.981209507, 2.981209507, -0.9937365024, -2.98743365, 2.974946133, -0.9875122361],
];

//主程序
export function iir_biquad_new(x) {
	let N_x = x.length;
	let buffer = new Array(N_x).fill(0);
	x = iir_biquad_stm323(x, IIRCoeff_H05_o3); //
	for (let i = 0; i < N_x; i++) {
		buffer[i] = x[N_x - i - 1]; //flip
	}
	buffer = iir_biquad_stm323_new(buffer, IIRCoeff_H05_50_o3);
	for (let i = 0; i < N_x; i++) {
		x[i] = buffer[N_x - i - 1]; //flip
	}
	x = iir_biquad_stm324(x, IIRCoeff_X50_o4);
	x = iir_biquad_stm324(x, IIRCoeff_X50_o4);

	let sig2 = new Array(N_x).fill(0);
	let n = 3;
	for (let index = 1500; index < x.length - n; index++) {
		sig2[index] = x[index] - mean(x.slice(index - n, index + n));
	}
	return iir_biquad_stm323(x, IIRCoeff_L35_o3);
}

//引用函数
function iir_biquad_stm323(x, Coeff) {
	//order 2阶批处理滤波器
	let N_x = x.length;
	let X0, X1, X2, X3, Y0, Y1, Y2, Y3;
	for (let i = 0; i < N_x; i++) {
		if (i == 0) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[0];
			Y0 = X0 * Coeff[0]; // a1y1 = b1x1
			Y1 = X1 * Coeff[0] + X0 * Coeff[1] - Y0 * Coeff[4];
			Y2 = X2 * Coeff[0] + X1 * Coeff[1] + X0 * Coeff[2] - Y1 * Coeff[4] - Y0 * Coeff[5];
		} else if (i == 1) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[1];
		} else if (i == 2) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[1];
			X3 = x[2];
		} else {
			X0 = x[i - 3];
			X1 = x[i - 2];
			X2 = x[i - 1];
			X3 = x[i];
		}
		if (i >= 3) {
			x[i - 3] = Y0;
		}
		Y3 = X3 * Coeff[0] + X2 * Coeff[1] + X1 * Coeff[2] + X0 * Coeff[3] - Y2 * Coeff[4] - Y1 * Coeff[5] - Y0 * Coeff[6];
		Y0 = Y1;
		Y1 = Y2;
		Y2 = Y3;
	}
	x[N_x - 3] = Y0;
	x[N_x - 2] = Y1;
	x[N_x - 1] = Y2;
	return x;
}

function iir_biquad_stm324(x, Coeff) {
	//order 2阶批处理滤波器
	let N_x = x.length;
	let X0, X1, X2, X3, X4, Y0, Y1, Y2, Y3, Y4;
	for (let i = 0; i < N_x; i++) {
		if (i == 0) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[0];
			X4 = x[0];
			Y0 = X0 * Coeff[0]; // a1y1 = b1x1
			Y1 = X1 * Coeff[0] + X0 * Coeff[1] - Y0 * Coeff[4];
			Y2 = X2 * Coeff[0] + X1 * Coeff[1] + X0 * Coeff[2] - Y1 * Coeff[4] - Y0 * Coeff[5];
			Y3 = X3 * Coeff[0] + X2 * Coeff[1] + X1 * Coeff[2] + X0 * Coeff[3] - Y2 * Coeff[5] - Y1 * Coeff[6] - Y0 * Coeff[7];
		} else if (i == 1) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[0];
			X4 = x[1];
		} else if (i == 2) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[1];
			X4 = x[2];
		} else if (i == 3) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[1];
			X3 = x[2];
			X4 = x[3];
		} else {
			X0 = x[i - 4];
			X1 = x[i - 3];
			X2 = x[i - 2];
			X3 = x[i - 1];
			X4 = x[i];
		}
		if (i >= 4) {
			x[i - 4] = Y0;
		}
		Y4 =
			X4 * Coeff[0] +
			X3 * Coeff[1] +
			X2 * Coeff[2] +
			X1 * Coeff[3] +
			X0 * Coeff[4] -
			Y3 * Coeff[5] -
			Y2 * Coeff[6] -
			Y1 * Coeff[7] -
			Y0 * Coeff[8];
		Y0 = Y1;
		Y1 = Y2;
		Y2 = Y3;
		Y3 = Y4;
	}
	x[N_x - 4] = Y0;
	x[N_x - 3] = Y1;
	x[N_x - 2] = Y2;
	x[N_x - 1] = Y3;
	return x;
}

function iir_biquad_stm323_new(x, Coeff) {
	//order 2阶批处理滤波器
	let fs = 500;
	let N_gear = 50;
	let L = x.length;
	let X0, X1, X2, X3, Y0, Y1, Y2, Y3;
	let wind = fs * 0.5; //观察窗口
	let Tswitch = 3 * fs; //切换帧数
	let thresh = 300;
	let TF5to05 = 0; //是否正在切换
	let TF05to5 = 0; //是否正在切换
	let m = 0;
	let alpha = 1;
	let sig = 1;
	let ind = 0;

	for (let i = 0; i < L; i++) {
		if (i == 0) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[0];
			Y0 = X0 * Coeff[50][0]; // a1y1 = b1x1
			Y1 = X1 * Coeff[50][0] + X0 * Coeff[50][1] - Y0 * Coeff[50][4];
			Y2 = X2 * Coeff[50][0] + X1 * Coeff[50][1] + X0 * Coeff[50][2] - Y1 * Coeff[50][4] - Y0 * Coeff[50][5];
		} else if (i == 1) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[0];
			X3 = x[1];
		} else if (i == 2) {
			X0 = x[0];
			X1 = x[0];
			X2 = x[1];
			X3 = x[2];
		} else {
			X0 = x[i - 3];
			X1 = x[i - 2];
			X2 = x[i - 1];
			X3 = x[i];
		}
		if (i >= 3) {
			x[i - 3] = Y0;
		}

		if (i - wind + 1 >= 0) {
			m = Math.abs(mean(x.slice(i - wind + 1, i + 1)));
		} else {
			m = 0;
		}

		//更新alpha
		sig = 1;
		alpha = 1;
		if ((sig == 0 && m >= thresh) || (sig == 1 && m < thresh)) {
			//如果没有切换，fc=5hz，且已经收敛,则切换至0.5
			TF05to5 = 0; //%不转换
			TF5to05 = 0;
		} else if (TF5to05) {
			//如果正在切换，必须先结束切换， alpha=0对应hz5
			sig = sig + 1 / Tswitch; //继续切换成hz0.5
			alpha = mapping5to05(sig); // (0,0) (1,1)
			if (sig >= 1) {
				sig = 1;
				TF5to05 = 0;
			}
		} else if (TF05to5) {
			//如果正在切换，必须先结束切换
			sig = sig - 1 / Tswitch; //%继续切换成hz0.5
			alpha = mapping05to5(sig);
			if (sig <= 0) {
				sig = 0;
				TF05to5 = 0;
			}
		} else if (sig == 0 && m < thresh) {
			//如果没有切换，fc=5hz，且已经收敛,则切换至0.5
			sig = Math.min(sig + 1 / Tswitch, 1); //继续切换成hz0.5
			alpha = mapping5to05(sig);
			TF5to05 = 1; //正在转换
			TF05to5 = 0;
		} else if (sig == 1 && m >= thresh) {
			//如果没有切换，fc=0.5hz，且没有收敛则切换至5
			sig = Math.max(sig - 1 / Tswitch, 0);
			alpha = mapping05to5(sig);
			TF05to5 = 1; //正在转换
			TF5to05 = 0;
		}

		//alpha更新完毕

		ind = Math.floor(alpha * N_gear);

		Y3 =
			X3 * Coeff[ind][0] +
			X2 * Coeff[ind][1] +
			X1 * Coeff[ind][2] +
			X0 * Coeff[ind][3] -
			Y2 * Coeff[ind][4] -
			Y1 * Coeff[ind][5] -
			Y0 * Coeff[ind][6];
		Y0 = Y1;
		Y1 = Y2;
		Y2 = Y3;
	}
	x[L - 3] = Y0;
	x[L - 2] = Y1;
	x[L - 1] = Y2;
	return x;
}

function mapping5to05(x) {
	return 1 - (1 - x) * (1 - x);
}

function mapping05to5(x) {
	let point = 0.9;
	if (x > point) {
		return (x - point) / (1 - point);
	} else {
		return 0;
	}
}

//中值滤波
//originalData, span 窗口一半
export function medianBiquad(originalData, span) {
	if (originalData.length < span) {
		return originalData;
	}
	//第一步构造新的原始数据 前后加个span
	let neworiginalData = [];
	for (let index = 0; index < span; index++) {
		neworiginalData.push(originalData[index]);
	}
	for (let index = 0; index < originalData.length; index++) {
		neworiginalData.push(originalData[index]);
	}
	for (let index = 0; index < span; index++) {
		neworiginalData.push(originalData[originalData.length - span + index]);
	}
	//先计算第一个窗口的中值
	let spanDataAry = [];
	for (let index = 0; index < 2 * span + 1; index++) {
		spanDataAry.push(neworiginalData[index]);
	}
	spanDataAry.sort((a, b) => a - b);

	let biquadData = [];
	for (let index = 0; index < originalData.length - 1; index++) {
		//先求出上个滤波后的值
		biquadData.push(originalData[index] - spanDataAry[span]);

		//移除值 加入新的值
		let j = spanDataAry.indexOf(neworiginalData[index]);
		spanDataAry.splice(j, 1);
		//加入新的值
		let newAddValue = neworiginalData[index + 2 * span + 1];
		let i = 0;
		for (i = 0; i < spanDataAry.length; i++) {
			if (spanDataAry[i] < newAddValue) {
				continue;
			}
			break;
		}

		spanDataAry.splice(i, 0, newAddValue);
	}
	biquadData.push(originalData[originalData.length - 1] - spanDataAry[span]);
	return biquadData;
}
